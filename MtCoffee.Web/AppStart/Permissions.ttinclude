<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ CleanupBehavior processor="T4VSHost" CleanupAfterProcessingtemplate="true" #>

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Linq;
using System.Collections.Generic;
using System.Web;
<#    if (Configuration.EnableHtmlHelpers) { #>
using Microsoft.AspNetCore.Mvc.ViewFeatures;
using Microsoft.AspNetCore.Mvc.Rendering;
<#    } #>
<#    if (Configuration.EnableHtmlHelpers || Configuration.EnableHasPermissionAttribute) { #>
using System.Security.Claims;
<#    } #>

namespace <#= Configuration.Namespace #>
{
    public static class <#= Configuration.EnumName #>
    {<# 
        Write(Helpers.PrintEnumProperties(Configuration.Nodes)); 
        Write(Helpers.PrintMasterValuesMap(Configuration.Nodes)); 
        Write(Helpers.PrintRolePermissionDictionary());
    #>

        public static List<string> Values { get => ValuesMap.Values.ToList(); }
        public static List<string> Keys { get => ValuesMap.Keys.ToList(); }
        
        // CanDoThing => thing.can.do
        public static List<KeyValuePair<string,string>> ToList()
        {
            return ValuesMap.ToList();
        }

        /// <summary>
        /// Lists all roles that have the given fully qualified permission node.
        /// </summary>
        /// <param name="node"></param>
        /// <returns></returns>
        public static List<string> GetRolesThatHavePermission(string node)
        {
            List<string> items = new List<string>();

            foreach(var grp in Permissions.RolePermissions.Keys)
            {
                if (Permissions.HasPermissionByRole(grp, node))
                {
                    items.Add(grp);
                }
            }

            return items;
        }


        ///<summary>
        /// This method checks to see if any of the roles in the rolecsv (list of roles, separated by commas)
        /// have the requested permission node. Returns true if any of them do. The full qualified permission
        /// node needs to come from the pre-defined constant values.
        ///</summary>
        public static bool HasPermissionByRole(string roleCsv, string fullyQualifiedPermissionNode)
        {
			if (string.IsNullOrWhiteSpace(roleCsv)) return false;
            string[] roles = roleCsv.Split(',').Select(x => x.Trim()).ToArray();

            foreach(string role in roles)
            {
                if (RolePermissions.ContainsKey(role))
                {
                    var perms = RolePermissions[role];
                    if (perms != null && perms.Contains(fullyQualifiedPermissionNode))
                    {
                        return true;
                    }
                }
            }

            return false;
        }


        public static void AddPermission(string role, string node)
        {
            if (!RolePermissions.ContainsKey(role)) RolePermissions[role] = new HashSet<string>();
            var nodes = GetFullyQualifiedPermissionNodes(node);

            foreach(string fq in nodes)
            {
                RolePermissions[role].Add(fq);
            }
        }

        public static void AddPermissions(string role, HashSet<string> nodes)
        {
            if (!RolePermissions.ContainsKey(role)) 
            {
                RolePermissions[role] = new HashSet<string>();
            }

            foreach(string s in nodes)
            {
                var fqNodes = GetFullyQualifiedPermissionNodes(s);
                foreach(string fq in fqNodes)
                {
                    RolePermissions[role].Add(fq);
                }
            }
        }
    
        private static HashSet<string> GetFullyQualifiedPermissionNodes(string nodeWithPossibleWildCard)
        {
            HashSet<string> nodes = new HashSet<string>();
            if (ValuesMap.Values.Contains(nodeWithPossibleWildCard))
            {
                nodes.Add(nodeWithPossibleWildCard);
            }
            else
            {
                // must be either not found, or a wildcard. Wildcard if ending in *
                if (nodeWithPossibleWildCard.EndsWith("*"))
                {
                    if (nodeWithPossibleWildCard == "*")
                    {
                        foreach(string fq in ValuesMap.Values)
                        {
                            nodes.Add(fq);
                        }
                    }
                    else if (nodeWithPossibleWildCard.EndsWith(".*"))
                    {
                        string needle = nodeWithPossibleWildCard.Substring(0, nodeWithPossibleWildCard.Length - 2);
                        foreach (string fq in ValuesMap.Values.Where(x => x.StartsWith(needle)))
                        {
                            nodes.Add(fq);
                        }
                    }
                }
            }

            return nodes;
        }
        

<#    if (Configuration.EnableHtmlHelpers) { #>

        ///<summary>
		/// Returns a comma separated vector of roles for the current user. This is stored as a
		/// Func<string> variable so that test implementations can override the default behavior here.
        ///</summary>
		public static Func<string> GetRolesCsvForCurrentUser = () => 
		{
            if (HttpContext.Current?.User?.Identity != null)
            {
                var ident = HttpContext.Current?.User.Identity;
                if (ident.IsAuthenticated)
                {
                    if (HttpContext.Current?.User is ClaimsPrincipal)
                    {
                        var principal = (ClaimsPrincipal) HttpContext.Current?.User;
                        string rolesCsv = principal.FindFirst(ClaimTypes.Role)?.Value;
                        return rolesCsv;
                    }
                }
            }

            return "";
        };


        ///<summary>
        /// This method checks a user's Role claim csv for roles. It then checks to see if any of those roles
        /// have the requested permission node.
        ///</summary>
        public static bool HasPermission(string node)
        {
            return HasPermissionByRole(GetRolesCsvForCurrentUser(), node);
        }


        ///<summary>
        /// This method checks a user's Role claim csv for roles. It then checks to see if any of those roles
        /// have the requested permission node.
        ///</summary>
        public static bool HasPermission(this IHtmlHelper html, string node)
        {
            if (html.ViewContext?.HttpContext?.User != null)
            {
                Claim claim = html.ViewContext.HttpContext.User.Claims.FirstOrDefault(c => c.Type == ClaimTypes.Role);
                if (claim != null)
                {
                    return HasPermissionByRole(claim.Value, node);
                }
            }

            return false;
        }
        <#
    }
#>  
    }

<#    if (Configuration.EnablePermissionModel) { #>
    public class <#= Configuration.EnumModelName #>
    {<#
        Write(Helpers.PrintEnumPropertiesForPermissionSet(Configuration.Nodes)); #>
        private Dictionary<string, bool> PermissionsGranted { get; }
        public string[] Roles { get; }
        public bool IsAuthenticated { get; set; } = false;

        public PermissionSet(string roleCsv)
        {
            // CanDo => can.do
            this.Roles = roleCsv?.Split(",") ?? new string[0];
            this.PermissionsGranted = new Dictionary<string, bool>();
            <#= Configuration.EnumName #>.ToList().ForEach(kvp => this.PermissionsGranted[kvp.Key] = <#= Configuration.EnumName #>.HasPermissionByRole(roleCsv, kvp.Value));
        }
    }
<#    } #>

}
    
    <#    if (Configuration.EnableHasPermissionAttribute) { #>
    namespace Microsoft.AspNetCore.Authorization {
        [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true, Inherited = true)]
        public class HasPermissionAttribute : Attribute, Mvc.Filters.IAuthorizationFilter
        {
            public string[] Nodes { get; set; }
            public HasPermissionAttribute(params string[] PermissionNodes)
            {
                this.Nodes = PermissionNodes;
            }

            public void OnAuthorization(Mvc.Filters.AuthorizationFilterContext context)
            {
                var roleCsv = context.HttpContext.User?.Claims.FirstOrDefault(c => c.Type == ClaimTypes.Role)?.Value ?? "";

                foreach (string fqNode in this.Nodes)
                {
                    if (<#= Configuration.Namespace +"."+ Configuration.EnumName #>.HasPermissionByRole(fqNode, roleCsv))
                    {
                        return; // Good to go. You have permission.
                    }
                }
            
                var result = new MtCoffee.Web.Models.JsonPayload<object>();
                if (Nodes.Length == 1)
                {
                    result.Errors.Add(string.Format("You do not have permission to perform the current operation. You lack the '{0}' permission node. If you feel this is in error, please contact an administrator.", Nodes[0]));
                }
                else
                {
                    result.Errors.Add(string.Format("You do not have permission to perform the current operation. You must have at least one of the following permissions: [{0}]", string.Join(",", Nodes)));
                }

                context.Result = result.ToJsonResult(401);
            }
        }
    }
    <#    } #>
<#+

public static class Helpers
{

        private static bool HasPermission(string fullyQualifiedPermissionNode, HashSet<string> givenPermissions)
        {
            if (givenPermissions == null || givenPermissions.Any() == false) return false;
            if (givenPermissions.Contains(fullyQualifiedPermissionNode)) return true;
            if (givenPermissions.Contains("*")) return true;

            string[] args = fullyQualifiedPermissionNode.Split('.');
            string needle = "";
            for (int i = 0; i < args.Length; i++)
            {
                if (i > 0) needle += ".";
                needle += args[i];
                if (givenPermissions.Contains(needle + ".*")) return true;
            }

            return false;
        }

        // Expands the specified permission nodes into the fully qualified permission nodes.
        public static string PrintRolePermissionDictionary(){
            var initialPermissions = Configuration.ConfigureRolePermissions();
            var compiledPermissions = Helpers.GetValuesMap();

            string output = "\r\n\r\n";
            output += Helpers._(8)+"//Role -> permissions[]\r\n        public static readonly Dictionary<string, HashSet<string>> RolePermissions = new Dictionary<string, HashSet<string>>()\r\n"+_(8)+"{\r\n";
            
            foreach(var grp in initialPermissions.Keys){
                var hashSetOfGroupPerms = new HashSet<string>(initialPermissions[grp]);
                var fullyQualifiedNodes = compiledPermissions.Where(permNode => Helpers.HasPermission(permNode.Value, hashSetOfGroupPerms)).Select(x => x.Value).OrderBy(x => x);
                output += _(12) + "{ \""+grp+"\", new HashSet<string>(){ ";
                if (fullyQualifiedNodes.Any()){
                    output += "\""+string.Join("\",\"",fullyQualifiedNodes)+"\" }},\r\n";
                }else{
                    output += "}},\r\n";
                }
            }
            output += Helpers._(8) + "};\r\n";

            return output;
        }
 
        public static string PrintEnumPropertiesForPermissionSet(object nodes)
        {
            string o = "";
            Type nodesTp = Configuration.Nodes.GetType();
            PropertyInfo[] props= nodesTp.GetProperties();
            
            for(int i = 0; i < props.Length; i++)
            {
                var prop = nodesTp.GetProperties()[i];
                o += "\r\n        public bool "+prop.Name+ " => this.PermissionsGranted[\""+prop.Name+"\"];";
            }
            o += "\r\n\r\n";

            return o;
        }
        
        public static string PrintEnumProperties(object nodes)
        {
            string o = "";
            Type nodesTp = Configuration.Nodes.GetType();
            PropertyInfo[] props= nodesTp.GetProperties();
            
            for(int i = 0; i < props.Length; i++)
            {
                var prop = nodesTp.GetProperties()[i];
                o += "\r\n        public const "+prop.PropertyType+" "+prop.Name+ " = "+Helpers.PrintPropertyValue(prop,Configuration.Nodes)+ ";";
            }
            o += "\r\n\r\n";

            return o;
        }

        private static Dictionary<string, string> GetValuesMap()
        {
            Type nodesTp = Configuration.Nodes.GetType();
            PropertyInfo[] props= nodesTp.GetProperties();
            var dic = new Dictionary<string,string>();
            for(int i = 0; i < props.Length; i++)
            {
                var prop = nodesTp.GetProperties()[i];
                dic[prop.Name] = prop.GetValue(Configuration.Nodes).ToString();
            }
            return dic;
        }

        public static string PrintMasterValuesMap(object nodes)
        {
            Type nodesTp = Configuration.Nodes.GetType();
            PropertyInfo[] props= nodesTp.GetProperties();
            string o = "        private static readonly Dictionary<string, string> ValuesMap = new Dictionary<string, string>()\r\n        {";
            for(int i = 0; i < props.Length; i++)
            {
                var prop = nodesTp.GetProperties()[i];
                o += "\r\n            { \""+prop.Name+"\", "+(Helpers.PrintPropertyValue(prop,Configuration.Nodes)+" },");
            }
            o += ("\r\n        };\r\n");

            return o;
        }
        

        public static string PrintPropertyValue(PropertyInfo prop, object objInstance)
        {
            switch(prop.PropertyType.ToString()){
                case "System.Double":
                    return prop.GetValue(objInstance).ToString()+"D";
                case "System.Float":
                    return prop.GetValue(objInstance).ToString()+"F";
                case "System.Decimal":
                    return prop.GetValue(objInstance).ToString()+"M";
                case "System.Long":
                    return prop.GetValue(objInstance).ToString()+"L";
                case "System.Boolean": 
                case "System.Int16":
                case "System.Int32":
                    return prop.GetValue(objInstance).ToString().ToLowerInvariant();
                case "System.String":
                    return "\""+prop.GetValue(objInstance)+"\"";
            }

            return prop.GetValue(objInstance).ToString();
        }

        public static string _ (int numSpaces)
        {
            string o = "";
            for(int i = 0; i < numSpaces; i++){
                o += " ";
            }

            return o;
        }
}
#>